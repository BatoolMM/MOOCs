<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: auth.controllers.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: auth.controllers.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const UUID = require('uuid').v4
const jwt = require('jsonwebtoken')
const crypto = require('crypto')

const config = require('../utils/config')
const asyncWrapper = require('./../utils/async_wrapper')
const sendEmail = require('./../utils/email')
const { CustomAPIError, BadRequestError, UnauthorizedError } = require('./../utils/custom_errors')
const { getAuthCodes } = require('../utils/auth_codes')
const { decodeJWT } = require('../utils/jwt_handler')

const { OAuth2Client } = require('google-auth-library');
const client = new OAuth2Client(config.GOOGLE_SIGNIN_CLIENT_ID);

const User = require('../models/user.models')
const { TestToken, BlacklistedToken } = require('../models/token.models')
const AuthCode = require('../models/authcode.models')

/**
 * Sign a token with the given payload and secret
 * 
 * @param {string} id 
 * @param {string} role 
 * @param {string} jwtSecret 
 * @param {string} expiry 
 * 
 * @returns {string} token
 * 
 * @throws {Error} if jwtSecret is not provided 
 */
const signToken = (id, role, jwtSecret = null, expiry = null) => {
    const expiryDate = expiry ? expiry : process.env.JWT_EXPIRES_IN
    if (!jwtSecret) { jwtSecret = config.JWT_ACCESS_SECRET }
    console.log(jwtSecret)
    return jwt.sign({ id, role }, jwtSecret, {
        expiresIn: expiryDate,
    })
}

/**
 * Create a token and send it to the client
 * 
 * @param {MongooseDocument} user 
 * @param {number} statusCode 
 * @param {ExpressResponseObject} res 
 * 
 * @returns {void}
 */
const createToken = (user, statusCode, res) => {
    const token = signToken(user._id, user.role, config.JWT_ACCESS_SECRET, config.JWT_EXPIRES_IN)
    const cookieOptions = {
        expires: new Date(
            Date.now() + process.env.JWT_COOKIE_EXPIRES * 24 * 60 * 60 * 1000,
        ),
        httpOnly: true,
    }
    if (process.env.NODE_ENV === 'production') cookieOptions.secure = true
    res.cookie('jwt', token, cookieOptions)

    // Remove sensitive data from user object
    user.password = undefined
    user.passwordConfirm = undefined
    user.emailVerificationToken = undefined
    user.passwordResetToken = undefined
    user.isVerified = undefined
    user.auth_code = undefined

    res.status(statusCode).json({
        status: 'success',
        token,
        data: {
            user,
        },
    })
}

/**
 * Signup a new user
 * 
 * @param {string} role
 * @param {string} email
 * @param {string} password
 * @param {string} passwordConfirm
 * @param {string} firstname
 * @param {string} lastname
 * 
 * @returns {object} user
 * @returns {string} token
 * @returns {string} status
 */
exports.signup = async (req, res, next) => {
    //1. Grab Values from req.body &amp; Store Values in database
    const currentUser = await (await User.create({
        firstname: req.body.firstname,
        lastname: req.body.lastname,
        email: req.body.email,
        role: req.body.role,
        password: req.body.password,
        passwordConfirm: req.body.passwordConfirm,
    })).populate('auth_codes')

    //2. Create email verification Token
    const ver_token = currentUser.createHashedToken('email_verification')
    currentUser.save({ validateBeforeSave: false })

    //3. Save to test token collection -- aids in running unit tests
    if (process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test') {
        await TestToken.create({
            user: currentUser._id,
            email_verification: ver_token
        })
    }

    //4. Send email to user
    const url = `${req.protocol}://${req.get(
        'host',
    )}/api/v1/auth/verifyemail/${ver_token}`

    const message = `Please click on the link below to verify your email address: ${url}`
    await sendEmail({
        email: currentUser.email,
        subject: 'Your email verification token link',
        message
    })

    createToken(currentUser, 200, res)
}

// Login a user
/**
 * Login a user
 * 
 * @param {string} email
 * @param {string} password
 * 
 * @returns {object} user
 * @returns {string} token
 * @returns {string} status
 * 
 * @throws {CustomAPIError} if email or password is not provided
 * @throws {CustomAPIError} if email or password is incorrect
 * @throws {CustomAPIError} if email is not verified
 * @throws {Error} if error occurs
 */
exports.login = async (req, res, next) => {
    const { email, password } = req.body

    //Check if fields are provided
    if (!email || !password) {
        return next(new CustomAPIError('Please Provide Email and Password', 400))
    }
    //check if email exists
    const currentUser = await User.findOne({ email }).select('+password')
    console.log(currentUser)
    //Check if email and password matches
    if (
        !currentUser ||
        !(await currentUser.comparePassword(password, currentUser.password))
    ) {
        return next(new CustomAPIError('Incorrect Email or Password', 400))
    }
    //Send token to client
    createToken(currentUser, 200, res)
}

// Email Verification for new users
/**
 * Verify a user's email
 * 
 * @param {string} token
 * 
 * @returns {string} status
 * 
 * @throws {CustomAPIError} if token is invalid or token has expired
 * @throws {Error} if error occurs
 */
exports.verifyEmail = async (req, res, next) => {
    //1. Get email verification token from query params
    const hashedToken = crypto
        .createHash('sha256')
        .update(req.params.token)
        .digest('hex')


    //2. If token is invalid or token has expired
    const user = await User.findOne({ emailVerificationToken: hashedToken }).select('+emailVerificationToken')
    if (!user) {
        return next(
            new CustomAPIError(
                'Token Invalid or Token Expired, Request for a new reset token',
                404,
            ),
        )
    }

    user.isVerified = true
    user.emailVerificationToken = undefined
    await user.save({ validateBeforeSave: false })

    return res.status(201).send({ status: 'success' })
}

/**
 * Send a password reset code to a user's email
 * 
 * @param {string} email
 * 
 * @returns {string} message
 * @returns {string} access_token
 */
exports.forgetPassword = async (req, res, next) => {
    const { email } = req.body

    if (!email) {
        throw new BadRequestError('Missing required parameter in request body')
    }

    const current_user = await (await User.findOne({ email })).populate('auth_codes')
    console.log(current_user)
    if (!current_user) { throw new BadRequestError('User does not exist') }

    const password_reset_code = (await getAuthCodes(current_user._id, 'password_reset')).password_reset
    sendEmail({
        email: current_user.email,
        subject: "Password reset",
        message: `This is your password reset code ${password_reset_code}`
    })
    const access_token =
        signToken(current_user.id, current_user.role,
            config.JWT_PASSWORDRESET_SECRET, config.JWT_PASSWORDRESET_EXPIRES_IN)


    return res.status(200).send({
        message: "Successful, Password reset code sent to users email",
        access_token
    })
}

// Reset Password
/**
 * Reset a user's password
 * 
 * @param {string} new_password
 * @param {string} password_reset_code
 * 
 * @returns {string} status
 * 
 * @throws {Error} if error occurs
 * @throws {BadRequestError} if user does not exist
 * @throws {BadRequestError} if Missing required parameter in request body
 * @throws {UnauthorizedError} if Authentication invalid
 * @throws {BadRequestError} if Password reset code is incorrect
 * @throws {BadRequestError} if Password reset code has expired
 * @throws {UnauthorizedError} if Access token expired
 */
exports.resetPassword = async (req, res, next) => {
    const { new_password, password_reset_code } = req.body

    // Check if new password and password reset code are provided
    if (!new_password || !password_reset_code) {
        throw new BadRequestError('Missing required parameter in request body')
    }

    // Check for valid authorization header
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer')) {
        throw new UnauthorizedError('Authentication invalid');
    }

    // Check if token is valid
    const jwtToken = authHeader.split(' ')[1];
    const payload = jwt.verify(jwtToken, config.JWT_PASSWORDRESET_SECRET);

    const authCode = await AuthCode.findOne({ user: payload.id });
    if (!authCode) { throw new UnauthorizedError('Access token expired') }

    // Check if user exists
    const current_user = await (await User.findOne({ _id: payload.id })).populate("auth_codes")
    console.log(current_user)
    if (!current_user) { throw new BadRequestError('User does not exist') }

    // Check if password reset code is valid
    if (password_reset_code !== authCode.password_reset) {
        throw new BadRequestError('Invalid password reset code')
    }

    // Change password
    await current_user.changePassword(new_password, current_user.password)

    // Delete auth code, blacklist jwt token
    BlacklistedToken.create({ token: jwtToken })
    // BlacklistToken.create({ token: jwtToken })

    return res.status(200).send({
        message: "Successfully reset password",
    })
}

// Google Signin
/**
 * Signin a user with google
 * 
 * @param {string} token
 * 
 * @returns {string} status
 * @returns {string} access_token
 * @returns {string} refresh_token
 * 
 * @throws {Error} if error occurs
 * @throws {BadRequestError} if Missing required parameter in request body
 * @throws {BadRequestError} if User does not exist
 * @throws {BadRequestError} if User is not verified
 */
exports.googleSignin = async (req, res, next) => {
    const authorization = req.headers.authorization;
    const token = authorization.split(' ')[1];

    // Verify id token
    const ticket = await client.verifyIdToken({
        idToken: token,
        audience: config.GOOGLE_SIGNIN_CLIENT_ID,
    }),
        payload = ticket.getPayload(),
        existing_user = await User.findOne({ email: payload.email });

    // Create new user in db
    const random_str = UUID(); // Random unique str as password, won't be needed for authentication
    if (!existing_user) {
        const user_data = {
            firstname: payload.given_name,
            lastname: payload.family_name,
            email: payload.email,
            role: 'EndUser',
            password: random_str,
            passwordConfirm: random_str
        };

        const new_user = await User.create(user_data);
        createToken(new_user, 200, res)
    }

    createToken(existing_user, 200, res)
};

// Get details of logged in user
/**
 * Get data for logged in user
 * 
 * @param {string} token
 * 
 * @returns {string} success
 * @returns {object} user
 * 
 * @throws {error} if error occured 
 */
exports.getLoggedInUser = async (req, res, next) => {
    // Check for valid authorization header
    const auth = req.headers.authorization;
    const token = auth.split(' ')[1];

    // Check if token is valid
    const payload = jwt.verify(token, config.JWT_ACCESS_SECRET);
    const user = await User.findById(payload.id);

    res.status(200).json({
        status: 'success',
        data: {
            user
        }
    })
}


</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#cancelEnrollment">cancelEnrollment</a></li><li><a href="global.html#createCourse">createCourse</a></li><li><a href="global.html#createExercise">createExercise</a></li><li><a href="global.html#createQuestion">createQuestion</a></li><li><a href="global.html#createToken">createToken</a></li><li><a href="global.html#deleteQuestion">deleteQuestion</a></li><li><a href="global.html#deleteVideo">deleteVideo</a></li><li><a href="global.html#forgetPassword">forgetPassword</a></li><li><a href="global.html#getCourses">getCourses</a></li><li><a href="global.html#getEnrolledCourses">getEnrolledCourses</a></li><li><a href="global.html#getEnrolledUsers">getEnrolledUsers</a></li><li><a href="global.html#getExercises">getExercises</a></li><li><a href="global.html#getLoggedInUser">getLoggedInUser</a></li><li><a href="global.html#getQuestions">getQuestions</a></li><li><a href="global.html#getVideo">getVideo</a></li><li><a href="global.html#googleSignin">googleSignin</a></li><li><a href="global.html#login">login</a></li><li><a href="global.html#resetPassword">resetPassword</a></li><li><a href="global.html#scoreAnswers">scoreAnswers</a></li><li><a href="global.html#signToken">signToken</a></li><li><a href="global.html#signup">signup</a></li><li><a href="global.html#updateQuestion">updateQuestion</a></li><li><a href="global.html#updateVideo">updateVideo</a></li><li><a href="global.html#uploadVideo">uploadVideo</a></li><li><a href="global.html#verifyEmail">verifyEmail</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.0</a> on Tue Jan 03 2023 17:27:59 GMT+0100 (West Africa Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
